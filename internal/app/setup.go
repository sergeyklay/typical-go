package app

import (
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"github.com/typical-go/typical-go/pkg/oskit"
	"github.com/typical-go/typical-go/pkg/tmplkit"
	"github.com/typical-go/typical-go/pkg/typgo"
	"github.com/urfave/cli/v2"
)

func cmdSetup() *cli.Command {
	return &cli.Command{
		Name:  "setup",
		Usage: "Setup typical-go",
		Flags: []cli.Flag{
			projectPkgFlag,
			typicalBuildFlag,
			typicalTmpFlag,
			&cli.BoolFlag{Name: "go-mod", Usage: "Initiate go.mod before setup"},
			&cli.BoolFlag{Name: "new", Usage: "Setup new project with standard layout and typical-build"},
		},
		Action: Setup,
	}
}

// Setup typical-go
func Setup(c *cli.Context) error {
	if c.Bool("go-mod") {
		if err := initGoMod(c); err != nil {
			return err
		}
	}

	p, err := GetParam(c)
	if err != nil {
		return err
	}

	if c.Bool("new") {
		newProject(p)
	}
	return createWrapper(p)
}

// initGoMod initiate gomodob
func initGoMod(c *cli.Context) error {
	fmt.Fprintf(oskit.Stdout, "Initiate go.mod\n")
	pkg := c.String(ProjectPkgParam)
	if pkg == "" {
		return errors.New("project-pkg is empty")
	}
	dir := filepath.Base(pkg)
	os.Mkdir(dir, 0777)
	var stderr strings.Builder
	if err := typgo.RunBash(c.Context, &typgo.Bash{
		Name:   "go",
		Args:   []string{"mod", "init", pkg},
		Stderr: &stderr,
		Dir:    dir,
	}); err != nil {
		return fmt.Errorf("%s: %s", err.Error(), stderr.String())
	}
	return nil
}

func createWrapper(p *Param) error {
	path := fmt.Sprintf("%s/typicalw", p.SetupTarget)
	fmt.Fprintf(oskit.Stdout, "Create '%s'\n", path)
	return tmplkit.WriteFile(path, typicalwTmpl, p)
}

func newProject(p *Param) {
	mainPkg := p.SetupTarget + "/cmd/" + p.ProjectName
	main := mainPkg + "/main.go"
	fmt.Fprintf(oskit.Stdout, "Create '%s'\n", main)
	os.MkdirAll(mainPkg, 0777)
	tmplkit.WriteFile(main, mainTmpl, p)

	appPkg := p.SetupTarget + "/internal/app"
	appStart := appPkg + "/start.go"
	fmt.Fprintf(oskit.Stdout, "Create '%s'\n", appStart)
	os.MkdirAll(appPkg, 0777)
	ioutil.WriteFile(appStart, []byte(appStartSrc), 0777)

	generatedPkg := p.SetupTarget + "/internal/generated/ctor"
	generatedDoc := generatedPkg + "/ctor.go"
	fmt.Fprintf(oskit.Stdout, "Create '%s'\n", generatedDoc)
	os.MkdirAll(generatedPkg, 0777)
	ioutil.WriteFile(generatedDoc, []byte(generatedDocSrc), 0777)

	typicalBuildPkg := p.SetupTarget + "/tools/typical-build"
	typicalBuild := typicalBuildPkg + "/typical-build.go"
	fmt.Fprintf(oskit.Stdout, "Create '%s'\n", typicalBuild)
	os.MkdirAll(typicalBuildPkg, 0777)
	tmplkit.WriteFile(typicalBuild, typicalBuildTmpl, p)
}

const typicalwTmpl = `#!/bin/bash

set -e

TYPTMP={{.TypicalTmp}}
TYPGO=$TYPTMP/bin/typical-go

if ! [ -s $TYPGO ]; then
	echo "Build typical-go"
	go build -o $TYPGO github.com/typical-go/typical-go
fi

$TYPGO run \
	-project-pkg="{{.ProjectPkg}}" \
	-typical-build="{{.TypicalBuild}}" \
	-typical-tmp=$TYPTMP \
	$@
`

const generatedDocSrc = `package ctor
`

const appStartSrc = `package app

import (
	"bufio"
	"fmt"
	"os"
	"time"
)

// Start app
func Start() {
	// TODO: change start app implementation
	fmt.Println("Hello world!")
	fmt.Print("Press 'Enter' to continue...")
	bufio.NewReader(os.Stdin).ReadBytes('\n')
}

// Shutdown app
func Shutdown() {
	// TODO: change graceful shutdown implementation
	fmt.Printf("Shutdown app at %s", time.Now())
}
`
const mainTmpl = `package main

// Autogenerated by Typical-Go. DO NOT EDIT.

import (
	"log"

	"{{.ProjectPkg}}/internal/app"
	_ "{{.ProjectPkg}}/internal/generated/ctor"
	"github.com/typical-go/typical-go/pkg/typapp"
)

func main() {
	if err := typapp.Run(app.Start, app.Shutdown); err != nil {
		log.Fatal(err.Error())
	}
}
`

const typicalBuildTmpl = `package main

import (
	"github.com/typical-go/typical-go/pkg/typast"
	"github.com/typical-go/typical-go/pkg/typapp"
	"github.com/typical-go/typical-go/pkg/typgo"
	"github.com/typical-go/typical-go/pkg/typmock"
)

var descriptor = typgo.Descriptor{
	ProjectName:    "{{.ProjectName}}",
	ProjectVersion: "0.0.1",

	Tasks: []typgo.Tasker{
		// annotate
		&typast.AnnotateMe{
			Annotators: []typast.Annotator{
				&typapp.CtorAnnotation{},
			},
		},
		// build
		&typgo.GoBuild{},
		// run
		&typgo.RunBinary{Before: typgo.TaskNames{"annotate", "build"}},
		// mock
		&typmock.GenerateMock{
			Sources: []string{"internal"},
		},
	},
}

func main() {
	typgo.Start(&descriptor)
}
`
